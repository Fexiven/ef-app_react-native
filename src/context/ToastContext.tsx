import { createContext, ReactNode, useCallback, useContext, useRef, useState } from "react";

/**
 * A toast message entry.
 */
export type ToastMessage = {
    /**
     * The ID of this toast, autogenerated, not stable.
     */
    id: number;

    /**
     * The type of the toast.
     */
    type: "info" | "warning" | "error";

    /**
     * The content, can be a React node.
     */
    content: ReactNode | string;

    /**
     * The time at which the message was queued.
     */
    queued: number;

    /**
     * The lifetime at initialization.
     */
    lifetime: number;

    /**
     * A group key, freely pickable if multiple consumers render toasts.
     */
    group?: any;
};

/**
 * Type of the toast context.
 */
export type ToastContextType = {
    /**
     * Current toast messages.
     */
    messages: ToastMessage[];

    /**
     * Offers a toast for presentation.
     * @param type The type of the toast.
     * @param content The content, can be a React node.
     * @param lifetime The lifetime.
     * @param group A group key, freely pickable if multiple consumers render toasts.
     */
    toast(type: "info" | "warning" | "error", content: ReactNode | string, lifetime?: number, group?: any): void;
};

/**
 * Toast context object.
 */
export const ToastContext = createContext<ToastContextType>({
    messages: [],
    toast() {},
});

/**
 * Prop types for a toast provider.
 */
export type ToastContextProviderProps = {
    /**
     * The children to provide for.
     */
    children?: ReactNode | undefined;
};

/**
 * Provides toast management.
 * @param children The children to provide for.
 * @constructor
 */
export const ToastContextProvider = ({ children }: ToastContextProviderProps) => {
    const idRef = useRef(0);
    const [messages, setMessages] = useState<ToastMessage[]>([]);
    const toast = useCallback((type: "info" | "warning" | "error", content: ReactNode | string, lifetime = 5000, group?: any) => {
        const queued = Date.now();
        const message = { id: idRef.current++, type, content, queued, lifetime, group };

        setMessages((current) => [...current, message]);
        setTimeout(() => {
            setMessages((current) => {
                const i = current.indexOf(message);
                return i < 0 ? current : [...current].splice(i, 1);
            });
        }, lifetime);
    }, []);

    return <ToastContext.Provider value={{ messages, toast }}>{children}</ToastContext.Provider>;
};

/**
 * Uses the entire toast context.
 */
export const useToastContext = () => useContext(ToastContext);

/**
 * Uses the toast method of the toast context.
 */
export const useToast = () => useContext(ToastContext).toast;

/**
 * Uses the current messages of the toast context.
 */
export const useToastMessages = () => useContext(ToastContext).messages;
